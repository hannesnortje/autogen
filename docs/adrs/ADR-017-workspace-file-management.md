# ADR-017: Workspace Integration and File Management

## Status
Accepted

## Context
The AutoGen MCP VS Code extension needs to seamlessly integrate with user workspaces, automatically detecting project types, watching for file changes, managing agent-generated files, and providing Git integration for version control. This integration should feel natural to developers and work across different project types (Python, TypeScript, JavaScript, mixed projects).

## Decision
We will implement a comprehensive workspace integration system consisting of five core services that work together to provide automatic project detection, file operations, version control, and real-time synchronization.

### Architecture Components

#### 1. WorkspaceManager
**Responsibility**: Project detection and configuration management
- Automatically detects project types (Python, TypeScript, JavaScript, mixed, unknown)
- Analyzes workspace folders for configuration files and project structure
- Manages AutoGen MCP configuration (`autogen-mcp.json`) per workspace
- Provides project-specific initialization and setup

**Key Features**:
- Configuration file detection (package.json, pyproject.toml, tsconfig.json, etc.)
- Git repository detection
- AutoGen MCP configuration lifecycle management
- Project type classification with extensible detection logic

#### 2. FileWatcher
**Responsibility**: Real-time file system monitoring and memory synchronization
- Watches workspace files for changes (create, modify, delete)
- Filters files based on configurable patterns and extensions
- Batches updates to reduce noise and improve performance
- Broadcasts file changes via WebSocket for real-time updates

**Key Features**:
- VS Code FileSystemWatcher integration
- Configurable file type filtering
- Ignore patterns for common build/cache directories
- Batched update processing with configurable delays
- Real-time memory service synchronization

#### 3. FileOperations
**Responsibility**: Agent-generated file management
- Creates and manages files generated by AutoGen agents
- Adds metadata headers to generated files for traceability
- Provides backup functionality for existing files
- Validates operations for security and workspace constraints

**Key Features**:
- Automatic agent metadata injection with language-specific comments
- File validation (extensions, paths, size limits)
- Backup creation for existing files
- Batch file operations
- Security restrictions for sensitive paths

#### 4. GitIntegration
**Responsibility**: Version control for agent-generated changes
- Creates commits with agent attribution
- Manages branches for agent work
- Provides repository initialization and status tracking
- Generates appropriate commit messages and metadata

**Key Features**:
- Agent-attributed commits with customizable prefixes
- Branch management for agent workflows
- Repository initialization with default .gitignore
- Git status monitoring and statistics
- Co-author support for human-agent collaboration

#### 5. WorkspaceConfiguration
**Responsibility**: Unified configuration management and service coordination
- Orchestrates all workspace services
- Provides project-specific configuration templates
- Manages per-workspace settings persistence
- Handles service lifecycle and configuration updates

**Key Features**:
- Project-type-specific configuration templates
- Deep configuration merging and validation
- Service coordination and lifecycle management
- Configuration import/export functionality
- Real-time configuration updates

### Integration Patterns

#### Service Coordination
```typescript
WorkspaceConfiguration
├── WorkspaceManager (project detection)
├── FileWatcher (file monitoring)
├── FileOperations (file management)
├── GitIntegration (version control)
└── RealtimeClient (WebSocket communication)
```

#### Configuration Flow
1. WorkspaceManager detects project type and structure
2. WorkspaceConfiguration selects appropriate template
3. Configuration is applied to all services
4. Services are initialized with workspace-specific settings
5. Real-time monitoring begins

#### File Change Workflow
1. FileWatcher detects file system change
2. Change is validated against configuration rules
3. Memory service is updated via RealtimeClient
4. Real-time notification is broadcast to connected clients
5. Optional Git operations are triggered based on configuration

#### Agent File Generation Workflow
1. Agent requests file creation via FileOperations
2. File content is enhanced with agent metadata
3. File is written with backup if existing file present
4. FileWatcher detects change and updates memory
5. GitIntegration creates commit with agent attribution

### Configuration Architecture

#### Project-Specific Templates
Different project types receive optimized configurations:

**Python Projects**:
- Watch: `.py`, `.md`, `.txt`, `.yaml`, `.yml`, `.json`
- Ignore: `__pycache__`, `venv`, `env`, `.pytest_cache`
- File operations: Python-specific comment metadata

**TypeScript Projects**:
- Watch: `.ts`, `.js`, `.json`, `.md`, `.yaml`, `.yml`
- Ignore: `node_modules`, `dist`, `build`
- File operations: TypeScript/JavaScript comment metadata

**Mixed Projects**:
- Combined configuration from multiple project types
- Extended ignore patterns
- Longer batch delays to handle complex project structures

#### Configuration Persistence
- Workspace-specific `autogen-mcp.json` files
- Version-controlled configuration for team consistency
- Environment-specific overrides support
- Migration support for configuration updates

## Consequences

### Positive
- **Seamless Integration**: Users experience automatic setup and configuration
- **Project Awareness**: Extension adapts to different project types and structures
- **Real-time Synchronization**: File changes are immediately reflected in memory service
- **Version Control Integration**: Agent changes are properly tracked and attributed
- **Scalable Architecture**: Services can be extended and configured independently
- **Developer Experience**: Familiar VS Code patterns and conventions

### Negative
- **Complexity**: Five interconnected services increase system complexity
- **Resource Usage**: File watching and real-time updates consume system resources
- **Configuration Overhead**: Project-specific templates require maintenance
- **Git Dependency**: Some features require Git repository initialization
- **Platform Differences**: File watching behavior varies across operating systems

### Risks and Mitigations

#### Performance Impact
- **Risk**: File watching can impact performance in large projects
- **Mitigation**: Configurable ignore patterns, batched updates, and selective watching

#### Configuration Conflicts
- **Risk**: Project-specific templates may conflict with user preferences
- **Mitigation**: Hierarchical configuration with user overrides, validation, and reset options

#### Git Integration Issues
- **Risk**: Automatic Git operations may conflict with user workflows
- **Mitigation**: Configurable Git features, branch isolation, and clear commit attribution

#### Service Dependencies
- **Risk**: Service interdependencies may cause cascading failures
- **Mitigation**: Graceful degradation, independent service initialization, and error isolation

### Implementation Considerations

#### Error Handling
- Each service implements comprehensive error handling
- Failed operations do not cascade to other services
- User feedback for critical errors, logging for debugging
- Graceful degradation when services are unavailable

#### Testing Strategy
- Unit tests for individual service functionality
- Integration tests for service coordination
- Mock implementations for external dependencies
- Workspace simulation for end-to-end testing

#### Extension Points
- Plugin architecture for additional project type detection
- Configurable file operation templates
- Extensible Git integration patterns
- Custom configuration templates

## Alternatives Considered

### Single Monolithic Service
**Rejected**: Would reduce flexibility and testability, making it difficult to configure or extend individual aspects of workspace integration.

### External Process Integration
**Rejected**: Would add complexity for process management and inter-process communication, reducing reliability and user experience.

### VS Code Built-in APIs Only
**Rejected**: Would limit functionality and real-time capabilities, making it difficult to provide comprehensive workspace integration.

### File System Polling Instead of Watching
**Rejected**: Would increase resource usage and reduce responsiveness compared to native file system watching APIs.

## Future Considerations

### Multi-workspace Support
- Support for multi-root VS Code workspaces
- Cross-workspace configuration sharing
- Workspace-specific service isolation

### Remote Development
- Integration with VS Code Remote Development
- Remote file system watching
- Network-efficient synchronization

### Enhanced Git Integration
- Pull request creation for agent changes
- Conflict resolution assistance
- Advanced branching strategies

### Performance Optimization
- Incremental file scanning
- Smart batching algorithms
- Resource usage monitoring and optimization

### Configuration Management
- Team-wide configuration templates
- Cloud-based configuration synchronization
- Advanced validation and schema support

This architecture provides a solid foundation for workspace integration while maintaining flexibility for future enhancements and different usage patterns.
